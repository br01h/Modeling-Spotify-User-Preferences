for (batch in 1:batches) {
start_idx <- 50*(batch-1)
if (batch < batches) {
end_idx <- start_idx + 50
} else {
end_idx <- last_batch_length
}
ids <- paste(track_ids[start_idx:end_idx], collapse = ',')
url <- glue('https://api.spotify.com/v1/tracks?ids={ids}')
response <- GET(url, add_headers(Accept = 'application/json',
Authorization = paste('Bearer', auth_token)))
Sys.sleep(0.1)
}
response
}
get_track_metadata(usr1_lib[1:5,])
# format data and append
#genres <- try(unlist(content(response)$artists$items[[1]]$genres))
#if (is.null(genres) | class(genres)=='try-error') { genres <- 'Unknown' }
#artistGenres <- rbind(artistGenres, data.frame(Artist = artists[i], Genres = genres))
r <- get_track_metadata(usr1_lib[1:5,])
r
r[1]
r <- get_track_metadata(usr1_lib[1:5,])
batches
r
r[1]
r[[1]]
ids <- paste(track_ids[start_idx:end_idx], collapse = '%2C')
get_track_metadata <- function(lib_frame) {
tracks <- lib_frame$track
tracks <- str_replace_all(tracks, pattern=' ', replacement='')
# convert to ID
track_ids <- do.call(rbind, lapply(tracks, getArtistID))$Artist.ID
n_ids <- length(track_ids)
# API token via wrappify
auth_token = getAuthenticationToken()
# batch since Spotify can only do 50 IDs at a time
batches <- ceiling(n_ids/50)
last_batch_length <- n_ids%%50
for (batch in 1:batches) {
start_idx <- 50*(batch-1)
if (batch < batches) {
end_idx <- start_idx + 50
} else {
end_idx <- last_batch_length
}
ids <- paste(track_ids[start_idx:end_idx], collapse = '%2C')
url <- glue('https://api.spotify.com/v1/audio-features?ids={ids}')
response <- GET(url, add_headers(Accept = 'application/json',
Authorization = paste('Bearer', auth_token)))
Sys.sleep(0.1)
}
response
}
r <- get_track_metadata(usr1_lib[1:5,])
r[[1]]
r[1]
r
usr1_lib[1:5,]
tracks <- usr1_lib$track[1:5]
tracks <- str_replace_all(tracks, pattern=' ', replacement='')
tracks
# convert to ID
track_ids <- do.call(rbind, lapply(tracks, getArtistID))$Artist.ID
track_ids
tracks
n_ids
n_ids <- length(track_ids)
# API token via wrappify
auth_token = getAuthenticationToken()
# batch since Spotify can only do 50 IDs at a time
batches <- ceiling(n_ids/50)
batches
last_batch_length <- n_ids%%50
last_batch_length
for (batch in 1:batches) {
start_idx <- 50*(batch-1)
if (batch < batches) {
end_idx <- start_idx + 50
} else {
end_idx <- last_batch_length
}
ids <- paste(track_ids[start_idx:end_idx], collapse = '%2C')
url <- glue('https://api.spotify.com/v1/audio-features?ids={ids}')
response <- GET(url, add_headers(Accept = 'application/json',
Authorization = paste('Bearer', auth_token)))
}
response
end_idx
start_idx
for (batch in 1:batches) {
start_idx <- 50*(batch-1)+1
if (batch < batches) {
end_idx <- start_idx + 50
} else {
end_idx <- last_batch_length
}
ids <- paste(track_ids[start_idx:end_idx], collapse = '%2C')
url <- glue('https://api.spotify.com/v1/audio-features?ids={ids}')
response <- GET(url, add_headers(Accept = 'application/json',
Authorization = paste('Bearer', auth_token)))
}
response
ids
for (batch in 1:batches) {
start_idx <- 50*(batch-1)+1
if (batch < batches) {
end_idx <- start_idx + 50
} else {
end_idx <- last_batch_length
}
ids <- paste(track_ids[start_idx:end_idx], collapse = ',')
url <- glue('https://api.spotify.com/v1/audio-features?ids={ids}')
response <- GET(url, add_headers(Accept = 'application/json',
Authorization = paste('Bearer', auth_token)))
}
response
ids
getArtistID('thorugh the fire and flames')
# convert to ID
track_ids <- do.call(rbind, lapply(tracks, getTrackID))$Track.ID
track_ids
# convert to ID
track_ids <- do.call(rbind, sapply(tracks, getTrackID, lim=1))$Track.ID
track_ids
# convert to ID
track_ids <- do.call(rbind, sapply(tracks, getTrackID, lim=1))#$Track.ID
track_ids
# convert to ID
track_ids <- do.call(rbind, sapply(tracks, getTrackID))#$Track.ID
track_ids
tracks
track_ids
# convert to ID
track_ids <- do.call(rbind, sapply(tracks, getTrackID))$Track.ID
track_ids
# convert to ID
track_ids <- do.call(rbind, sapply(tracks, getTrackID, lim=1))$Track.ID
track_ids
getTrackID(tracks[1])
getTrackID('ThatsHowYouFeel')
getTrackID('Thats How You Feel')
tracks <- usr1_lib$track[1:5]
# convert to ID
track_ids <- do.call(rbind, sapply(tracks, getTrackID, lim=1))$Track.ID
# convert to ID
track_ids <- do.call(rbind, sapply(tracks, getTrackID, lim=1))
track_ids
# convert to ID
track_ids <- list(sapply(tracks, getTrackID, lim=1))
track_ids
# convert to ID
track_ids <- list(sapply(tracks, getTrackID, lim=1)$Track.ID)
track_ids
# convert to ID
track_ids <- sapply(tracks, getTrackID, lim=1)
track_ids
# convert to ID
track_ids <- apply(tracks, getTrackID, lim=1)
# convert to ID
track_ids <- lapply(tracks, getTrackID, lim=1)
track_ids
# convert to ID
track_ids <- do.call(rbind, lapply(tracks, getTrackID, lim=1))
track_ids
# convert to ID
track_ids <- do.call(rbind, lapply(tracks, getTrackID, lim=1))$Track.ID
track_ids
# convert to ID
track_ids <- do.call(rbind, lapply(tracks, getTrackID, lim=1))
track_ids
track_ids[,3]
# convert to ID
track_ids <- do.call(rbind, lapply(tracks, getTrackID, lim=1))$Track.IDs
track_ids
# convert to ID
track_ids <- do.call(rbind, lapply(tracks, getTrackID, lim=1))#$Track.IDs
track_ids
track_ids <- track_ids[track_ids != ""]
track_ids
# convert to ID
track_ids <- do.call(rbind, lapply(tracks, getTrackID, lim=1))$Track.ID
track_ids <- track_ids[track_ids != ""]
track_ids
# batch since Spotify can only do 50 IDs at a time
batches <- ceiling(n_ids/50)
last_batch_length <- n_ids%%50
for (batch in 1:batches) {
start_idx <- 50*(batch-1)+1
if (batch < batches) {
end_idx <- start_idx + 50
} else {
end_idx <- last_batch_length
}
ids <- paste(track_ids[start_idx:end_idx], collapse = '$2C')
url <- glue('https://api.spotify.com/v1/audio-features?ids={ids}')
response <- GET(url, add_headers(Accept = 'application/json',
Authorization = paste('Bearer', auth_token)))
}
response
for (batch in 1:batches) {
start_idx <- 50*(batch-1)+1
if (batch < batches) {
end_idx <- start_idx + 50
} else {
end_idx <- last_batch_length
}
ids <- paste(track_ids[start_idx:end_idx], collapse = ',')
url <- glue('https://api.spotify.com/v1/audio-features?ids={ids}')
response <- GET(url, add_headers(Accept = 'application/json',
Authorization = paste('Bearer', auth_token)))
}
response
unlist(content(response))
unlist(content(response))$audio_features
unlist(content(response)$audio_features)
content(response)$audio_features
data.frame(content(response)$audio_features)
data.frame(rbind(content(response)$audio_features))
data.frame(do.call(rbind(content(response)$audio_features)))
(content(response)$audio_features))
content(response)$audio_features
content(response)$audio_features[1]
lapply(content(response)$audio_features, rbind)
data.frame(lapply(content(response)$audio_features, rbind))
lapply(content(response)$audio_features, rbind)
sapply(content(response)$audio_features, rbind)
rbind.data.frame(content(response)$audio_features)
content(response)$audio_features
rbind(track_features, content(response)$audio_features)
#data.frame(
track_features <- NULL
rbind(track_features, content(response)$audio_features)
content(response)$audio_features[1]
for (i in 1:50) {
tmp <- rbind(tmp, content(response)$audio_features[1])
}
tmp <- NULL
for (i in 1:50) {
tmp <- rbind(tmp, content(response)$audio_features[1])
}
tmp
tmp <- NULL
for (i in 1:5) {
tmp <- rbind(tmp, content(response)$audio_features[1])
}
for (i in 1:5) {
tmp <- rbind.data.frame(tmp, content(response)$audio_features[1])
}
tmp
tmp
tmp <- NULL
for (i in 1:5) {
tmp <- rbind.data.frame(tmp, content(response)$audio_features[1])
}
data.frame(content(response)$audio_features[1])
tmp <- NULL
for (i in 1:5) {
tmp <- rbind(tmp, data.frame(content(response)$audio_features[1]))
}
tmp
for (i in 1:5) {
tmp <- rbind(tmp, data.frame(content(response)$audio_features[i]))
}
tmp
tmp <- NULL
for (i in 1:5) {
tmp <- rbind(tmp, data.frame(content(response)$audio_features[i][1:11]))
}
for (i in 1:5) {
tmp <- rbind(tmp, data.frame(content(response)$audio_features[i][,1:11]))
}
tmp <- tmp[1:11]
tmp
tmp <- NULL
for (i in 1:5) {
tmp <- rbind(tmp, data.frame(content(response)$audio_features[i]))
}
tmp <- tmp[1:11]
tmp
nrow(data.frame(content(response)$audio_features)
nrow(data.frame(content(response)$audio_features))
length(data.frame(content(response)$audio_features))
length((content(response)))
content(response)
length((content(response)$audio_features))
sapply(content(response)$audio_features, data.frame)
rbindlist(sapply(content(response)$audio_features, data.frame))
library(data.table)
rbindlist(sapply(content(response)$audio_features, data.frame))
sapply(content(response)$audio_features, data.frame)
type(sapply(content(response)$audio_features, data.frame))
oftype(sapply(content(response)$audio_features, data.frame))
typeof(sapply(content(response)$audio_features, data.frame))
rbindlist(sapply(content(response)$audio_features, data.frame))
typeof(lapply(content(response)$audio_features, data.frame))
rbindlist(lapply(content(response)$audio_features, data.frame))
get_track_metadata <- function(lib_frame) {
tracks <- lib_frame$track
# convert to vector of IDs
track_ids <- do.call(rbind, lapply(tracks, getTrackID, lim=1))$Track.ID
track_ids <- track_ids[track_ids != ""]
n_ids <- length(track_ids)
# API token via wrappify
auth_token = getAuthenticationToken()
# collection
track_features <- NULL
# batch since Spotify can only do 50 IDs at a time
batches <- ceiling(n_ids/50)
last_batch_length <- n_ids%%50
for (batch in 1:batches) {
start_idx <- 50*(batch-1)+1
if (batch < batches) {
end_idx <- start_idx + 50
} else {
end_idx <- last_batch_length
}
ids <- paste(track_ids[start_idx:end_idx], collapse = ',')
url <- glue('https://api.spotify.com/v1/audio-features?ids={ids}')
response <- GET(url, add_headers(Accept = 'application/json',
Authorization = paste('Bearer', auth_token)))
batch_features <- rbindlist(lapply(content(response)$audio_features, data.frame))
track_features <- rbind(track_features, batch_features)
Sys.sleep(0.1)
}
track_features <- track_features[1:11]
track_features
}
get_track_metadata(usr1_lib[1:5])
get_track_metadata(usr1_lib[1:5,])
for (batch in 1:batches) {
start_idx <- 50*(batch-1)+1
if (batch < batches) {
end_idx <- start_idx + 50
} else {
end_idx <- last_batch_length
}
ids <- paste(track_ids[start_idx:end_idx], collapse = ',')
url <- glue('https://api.spotify.com/v1/audio-features?ids={ids}')
response <- GET(url, add_headers(Accept = 'application/json',
Authorization = paste('Bearer', auth_token)))
track_features <- rbindlist(track_features, rbindlist(lapply(content(response)$audio_features, data.frame)))
#track_features <- rbind(track_features, batch_features)
Sys.sleep(0.1)
}
get_track_metadata <- function(lib_frame) {
tracks <- lib_frame$track
# convert to vector of IDs
track_ids <- do.call(rbind, lapply(tracks, getTrackID, lim=1))$Track.ID
track_ids <- track_ids[track_ids != ""]
n_ids <- length(track_ids)
# API token via wrappify
auth_token = getAuthenticationToken()
# collection
track_features <- NULL
# batch since Spotify can only do 50 IDs at a time
batches <- ceiling(n_ids/50)
last_batch_length <- n_ids%%50
for (batch in 1:batches) {
start_idx <- 50*(batch-1)+1
if (batch < batches) {
end_idx <- start_idx + 50
} else {
end_idx <- last_batch_length
}
ids <- paste(track_ids[start_idx:end_idx], collapse = ',')
url <- glue('https://api.spotify.com/v1/audio-features?ids={ids}')
response <- GET(url, add_headers(Accept = 'application/json',
Authorization = paste('Bearer', auth_token)))
track_features <- rbindlist(track_features, rbindlist(lapply(content(response)$audio_features, data.frame)))
#track_features <- rbind(track_features, batch_features)
Sys.sleep(0.1)
}
track_features <- track_features[1:11]
track_features
}
get_track_metadata(usr1_lib[1:5,])
get_track_metadata <- function(lib_frame) {
tracks <- lib_frame$track
# convert to vector of IDs
track_ids <- do.call(rbind, lapply(tracks, getTrackID, lim=1))$Track.ID
track_ids <- track_ids[track_ids != ""]
n_ids <- length(track_ids)
# API token via wrappify
auth_token = getAuthenticationToken()
# collection
track_features <- NULL
# batch since Spotify can only do 50 IDs at a time
batches <- ceiling(n_ids/50)
last_batch_length <- n_ids%%50
for (batch in 1:batches) {
start_idx <- 50*(batch-1)+1
print(start_idx)
if (batch < batches) {
end_idx <- start_idx + 50
} else {
end_idx <- last_batch_length
}
print(end_idx)
ids <- paste(track_ids[start_idx:end_idx], collapse = ',')
url <- glue('https://api.spotify.com/v1/audio-features?ids={ids}')
response <- GET(url, add_headers(Accept = 'application/json',
Authorization = paste('Bearer', auth_token)))
batch_features <- rbindlist(lapply(content(response)$audio_features, data.frame))
print(batch_features)
track_features <- rbind(track_features, batch_features)
print(track_features)
Sys.sleep(0.1)
}
track_features <- track_features[1:11]
track_features
}
get_track_metadata(usr1_lib[1:5,])
get_track_metadata <- function(lib_frame) {
tracks <- lib_frame$track
# convert to vector of IDs
track_ids <- do.call(rbind, lapply(tracks, getTrackID, lim=1))$Track.ID
track_ids <- track_ids[track_ids != ""]
n_ids <- length(track_ids)
# API token via wrappify
auth_token = getAuthenticationToken()
# collection
track_features <- NULL
# batch since Spotify can only do 50 IDs at a time
batches <- ceiling(n_ids/50)
last_batch_length <- n_ids%%50
for (batch in 1:batches) {
start_idx <- 50*(batch-1)+1
if (batch < batches) {
end_idx <- start_idx + 50
} else {
end_idx <- last_batch_length
}
ids <- paste(track_ids[start_idx:end_idx], collapse = ',')
url <- glue('https://api.spotify.com/v1/audio-features?ids={ids}')
response <- GET(url, add_headers(Accept = 'application/json',
Authorization = paste('Bearer', auth_token)))
batch_features <- rbindlist(lapply(content(response)$audio_features, data.frame))
track_features <- rbind(track_features, batch_features)
Sys.sleep(0.1)
}
track_features <- track_features[, 1:11]
track_features
}
get_track_metadata(usr1_lib[1:5,])
get_track_metadata <- function(lib_frame) {
tracks <- lib_frame$track
# convert to vector of IDs
track_ids <- do.call(rbind, lapply(tracks, getTrackID, lim=1))$Track.ID
track_ids <- track_ids[track_ids != ""]
n_ids <- length(track_ids)
# API token via wrappify
auth_token = getAuthenticationToken()
# collection
track_features <- NULL
# batch since Spotify can only do 50 IDs at a time
batches <- ceiling(n_ids/50)
last_batch_length <- n_ids%%50
for (batch in 1:batches) {
start_idx <- 50*(batch-1)+1
if (batch < batches) {
end_idx <- start_idx + 50
} else {
end_idx <- last_batch_length
}
ids <- paste(track_ids[start_idx:end_idx], collapse = ',')
url <- glue('https://api.spotify.com/v1/audio-features?ids={ids}')
response <- GET(url, add_headers(Accept = 'application/json',
Authorization = paste('Bearer', auth_token)))
batch_features <- rbindlist(lapply(content(response)$audio_features, data.frame))
track_features <- rbind(track_features, batch_features)
Sys.sleep(0.1)
}
track_features <- track_features[, 1:11]
track_features
}
usr1_lib_features <- get_track_metadata(usr1_lib)
usr2_lib_features <- get_track_metadata(usr2_lib)
usr2_lib_features
usr1_lib_features
summary(usr1_lib_features)
summary(c(usr1_lib_features,usr1_lib_features))
summary(usr1_lib_features)
summary(usr1_lib_features)
summary(usr1_lib_features)
summary(usr2_lib_features)
plot(summary(usr1_lib_features))
summary(usr1_lib_features)
summary(usr2_lib_features)
summary(usr1_lib_features)
print()
summary(usr1_lib_features)
print('')
summary(usr2_lib_features)
summary(usr1_lib_features)
summary(usr2_lib_features)
track_ids
rm(nrow)
# Genres
write.csv(usr1_genres, '../Enhanced_Data/User1/usr1_genres.csv', row.names=FALSE)
write.csv(usr2_genres, '../Enhanced_Data/User2/usr2_genres.csv', row.names=FALSE)
# Streams
write.csv(usr1_streams, '../Enhanced_Data/User1/usr1_streams.csv', row.names=FALSE)
write.csv(usr2_streams, '../Enhanced_Data/User2/usr2_streams.csv', row.names=FALSE)
# Lib song IDs
write.csv(ids, '../Enhanced_Data/User2/usr2_lib_ids.csv', row.names=FALSE)
# Audio Features
write.csv(usr1_lib_features, '../Enhanced_Data/User1/usr1_lib_features.csv', row.names=FALSE)
write.csv(usr2_lib_features, '../Enhanced_Data/User2/usr2_lib_features.csv', row.names=FALSE)
# Peek
usr1_lib2
